# Solitaire UTF-8
支持UTF-8版的卡牌加密算法

# 例子
```python
instance = solitaire_utf8()
deck = [30, 35, 16, 47, 49, 43, 25, 8, 17, 50, 22, 36, 51, 32, 52, 27, 2, 48, 1, 37, 29, 42, 23, 38, 4, 41, 44, 34, 9, 14, 26, 5, 15, 13, 46, 31, 40, 18, 45, 28, 12, 33, 19, 7, 11, 3, 21, 10, 39, 20, 24, 6]

instance.init_deck(deck)
instance.init_joker(51,52)

encrypted_jp = instance.encrypt("作品の制作過程は、大きく分けると3つの工程に別れている。")
# F22E197B158AED0E6F0AA5524A70B06B254B30C38836BE00C7E2D8609A6604164B860A3817F7A4E9CB8840BB209325AB5AB5DCAFF17441A06FE5CCA13E5A949475CF193F344D85EEF99EBD33B0DE91B28E13
encrypted_cn = instance.encrypt("汉语，又称中国语（日本、韩国等），其他名称有汉文、中文、华文、唐文（书写）、唐话、中国话（语言）等[注 1]，是属汉藏语系的分析语，具有声调。")
# F422067E21A6E9394D0AAC244D6AD4665C6A3EB6BA3BDC0EC31EDF618D6407216A86093A1B0EC7EBD5A444D62E9F508C068ED7E093A987764E2575869A1EC3DF2CC05A0D3BA738E4363BBD9385F9FC65857426A5A308CCB6E4CC7A3785EBFEBADA60F063047FEB8559B9221CD48282C4F275A9003200A7B5E5F5941A6CCDBB01397BEA5ECEBCFB1E31CCEBE9F008FC29C9DD5F6E6251E041D59C101A6D38FA3C608C626A3969E4C378C40DE89C7DC6C20E9BD5E302A7BACA821086DB24A6E6A7DDF2165E1F259CE7192B0DBEB0
decrypted_jp = instance.decrypt(encrypted_jp)
decrypted_cn = instance.decrypt(encrypted_cn)
```

## 运行原理
首先我们将句子转换为bytes，在上面的例子中，"作品の制作過程は、大きく分けると3つの工程に別れている。", 变为：<br>
b'\xe4\xbd\x9c\xe5\x93\x81\xe3\x81\xae\xe5\x88\xb6\xe4\xbd\x9c\xe9\x81\x8e\xe7\xa8\x8b\xe3\x81\xaf\xe3\x80\x81\xe5\xa4\xa7\xe3\x81\x8d\xe3\x81\x8f\xe5\x88\x86\xe3\x81\x91\xe3\x82\x8b\xe3\x81\xa83\xe3\x81\xa4\xe3\x81\xae\xe5\xb7\xa5\xe7\xa8\x8b\xe3\x81\xab\xe5\x88\xa5\xe3\x82\x8c\xe3\x81\xa6\xe3\x81\x84\xe3\x82\x8b\xe3\x80\x82'

接着我们将这个变成每一个byte用两个字符代表的字符串：<br>
E4BD9CE59381E381AEE588B6E4BD9CE9818EE7A88BE381AFE38081E5A4A7E3818DE3818FE58886E38191E3828BE381A833E381A4E381AEE5B7A5E7A88BE381ABE588A5E3828CE381A6E38184E3828BE38082

这一步完成之后，我们便可以生成密匙了！

首先加密算法必须有一组卡牌，多少张牌没有关系。加密算法也需要知道两张王是什么。

在上面的例子中，我们有一组卡牌：<br>
30, 35, 16, 47, 49, 43, 25, 8, 17, 50, 22, 36, 51, 32, 52, 27, 2, 48, 1, 37, 29, 42, 23, 38, 4, 41, 44, 34, 9, 14, 26, 5, 15, 13, 46, 31, 40, 18, 45, 28, 12, 33, 19, 7, 11, 3, 21, 10, 39, 20, 24, 6<br>
我们也知道王1为`51`，王2为`52`

首先加密算法将王1下移一格，牌组变为如下：<br>
30, 35, 16, 47, 49, 43, 25, 8, 17, 50, 22, 36, <b>32, 51</b>, 52, 27, 2, 48, 1, 37, 29, 42, 23, 38, 4, 41, 44, 34, 9, 14, 26, 5, 15, 13, 46, 31, 40, 18, 45, 28, 12, 33, 19, 7, 11, 3, 21, 10, 39, 20, 24, 6

接着将王2下移两格，牌组变为如下：<br>
30, 35, 16, 47, 49, 43, 25, 8, 17, 50, 22, 36, 32, 51, <b>27, 2, 52</b>, 48, 1, 37, 29, 42, 23, 38, 4, 41, 44, 34, 9, 14, 26, 5, 15, 13, 46, 31, 40, 18, 45, 28, 12, 33, 19, 7, 11, 3, 21, 10, 39, 20, 24, 6

然后将第一个王上面的牌放到下方，第二个王下面的牌放到上方，牌组变为如下：<br>
<b>48, 1, 37, 29, 42, 23, 38, 4, 41, 44, 34, 9, 14, 26, 5, 15, 13, 46, 31, 40, 18, 45, 28, 12, 33, 19, 7, 11, 3, 21, 10, 39, 20, 24, 6</b>, 51, 27, 2, 52, <b>30, 35, 16, 47, 49, 43, 25, 8, 17, 50, 22, 36, 32</b>

接着将最后一张牌数目的牌，从前方插入到最后一张牌前面：<br>
20, 24, 6, 51, 27, 2, 52, 30, 35, 16, 47, 49, 43, 25, 8, 17, 50, 22, 36, <b>48, 1, 37, 29, 42, 23, 38, 4, 41, 44, 34, 9, 14, 26, 5, 15, 13, 46, 31, 40, 18, 45, 28, 12, 33, 19, 7, 11, 3, 21, 10, 39</b>, 32

接着选择在第一张牌数字位置的牌，在这个情况下是位置为20的牌：
20, 24, 6, 51, 27, 2, 52, 30, 35, 16, 47, 49, 43, 25, 8, 17, 50, 22, 36, 48, <b>1</b>, 37, 29, 42, 23, 38, 4, 41, 44, 34, 9, 14, 26, 5, 15, 13, 46, 31, 40, 18, 45, 28, 12, 33, 19, 7, 11, 3, 21, 10, 39, 32

如果这个数字不是王的话，这个就是我们的密匙流密匙。如果是王的话，从头再来。

每一个需要加密的字符都要经过这个过程算出密匙。

在上面的例子中，"作品の制作過程は、大きく分けると3つの工程に別れている。" 需要164个密匙流密匙。加密算法算出来的密匙串为：<br>
1, 14, 39, 17, 8, 29, 25, 6, 8, 50, 16, 41, 16, 42, 8, 29, 28, 49, 18, 37, 50, 29, 26, 28, 6, 6, 28, 35, 34, 20, 8, 18, 42, 20, 12, 13, 5, 41, 50, 27, 16, 13, 37, 19, 19, 45, 6, 17, 30, 36, 38, 18, 37, 7, 8, 11, 47, 38, 12, 47, 2, 49, 25, 37, 44, 46, 10, 19, 8, 41, 27, 41, 19, 34, 23, 31, 34, 46, 48, 38, 4, 42, 15, 23, 38, 13, 3, 9, 26, 5, 43, 32, 26, 20, 48, 35, 50, 7, 29, 50, 37, 11, 16, 11, 49, 46, 15, 19, 10, 19, 28, 43, 43, 24, 20, 16, 30, 5, 32, 9, 27, 35, 7, 39, 1, 19, 47, 25, 9, 32, 4, 7, 7, 4, 5, 44, 27, 2, 44, 33, 10, 50, 6, 13, 21, 35, 27, 11, 3, 44, 11, 47, 29, 45, 37, 28, 1, 22, 29, 47, 48, 14, 41, 49

我们将要加密的字符串变成一列数字，1=0一直到F=15。 然后计算（要加密的字符 + 密匙） mod 16。 将拿到的数字返回到字符串。<br>
这时我们便有了加密好的字符串：<br>
F22E197B158AED0E6F0AA5524A70B06B254B30C38836BE00C7E2D8609A6604164B860A3817F7A4E9CB8840BB209325AB5AB5DCAFF17441A06FE5CCA13E5A949475CF193F344D85EEF99EBD33B0DE91B28E13

解密同理，（要加密的字符 - 密匙） mod 16 就可以解密了。
